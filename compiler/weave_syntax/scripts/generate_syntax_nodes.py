import os

class SyntaxProperty:
    def __init__(self, name, type):
        self.name = name
        self.type = type

    def initializer_name(self):
        return self.name[0].lower() + self.name[1:]

class SyntaxNode:
    def __init__(self, name, base, abstract, properties):
        self.name = name
        self.base = base
        self.properties = properties
        self.abstract = abstract


TOKEN_TYPE = "weave::tokenizer::Token*";

nodes = [
    SyntaxNode("Statement", "SyntaxNode", True, []),
    SyntaxNode("EmptyStatement", "Statement", False, []),
    SyntaxNode("BlockStatement", "Statement", False, [
        SyntaxProperty("OpenBraceToken", TOKEN_TYPE),
        SyntaxProperty("Statements", "std::span<Statement*>"),
        SyntaxProperty("CloseBraceToken", TOKEN_TYPE),
    ]),
]

def print_node(node):
    print(f"class {node.name} : public {node.base} {{")
    print("public:")
    print("    static constexpr bool ClassOf(SyntaxKind kind)")
    print("    {")
    print(f"        return kind == SyntaxKind::{node.name};")
    print("    }")
    print("")
    print("    static cosntexpr bool ClassOf(SyntaxNode const* node)")
    print("    {")
    print("        return ClassOf(node->Kind());")
    print("    }")
    print("")
    print("public:")
    print(f"    explicit constexpr {node.name}(")

    for index, property in enumerate(node.properties):
        if index > 0:
            print(",")
        print(f"        {property.type} {property.initializer_name()}", end = '')

    print(f")")

    print("};")

def main():
    for node in nodes:
        print_node(node)
    #with open(os.path.join(os.path.dirname(__file__), '..', 'tokens.txt'), 'w') as f:
    #    f.write('// This file is generated by generate_tokens.py\n')
    #    for macro, group in all.items():
    #        for tokens in group:
    #            write_tokens(f, macro, tokens)


if __name__ == '__main__':
    main()
